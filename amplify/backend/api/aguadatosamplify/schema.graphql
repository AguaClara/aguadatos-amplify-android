# This "input" configures a global authorization rule to enable public access to
# all models in this schema. Learn more about authorization rules here: https://docs.amplify.aws/cli/graphql/authorization-rules
input AMPLIFY { globalAuthRule: AuthRule = { allow: public } } # FOR TESTING ONLY!

# NOTE: Due to AWS Amplify lack of support for polymorphism or union types, we had to denormalized the
# schema significantly.

# FUTURE IMPROVEMENT: A strategy to bypasses the lack of support would be to create an intermediary
# model called Entry to store metadata like author, createdAt, Entry type discriminator. Each
# entry's actual data are stored in their respective Entry models. However, this approach would
# require GraphQL resolvers, which are beyond our current scope and beta testing deadline.

enum ChemicalType {
    """
    Specifies the type of chemical an operator is calibrating and dosing.

    COAGULANT: Used during flocculation where organic matters are accumulated for filtering.
    CHLORINE: Used for disinfecting purposes.
    """
    COAGULANT
    CHLORINE
}

enum CoagType {
    """
    Specifies the type of coagulant a plant is using. This Enum should be used in calibration and
    dose entries whenever ChemType is COAGULANT.

    ALUM_SULFATE: Aluminium Sulfate.
    POLY_ALUM_CHLOR: Poly Aluminium Chloride.
    """
    ALUM_SULFATE
    POLY_ALUM_CHLOR
}

enum ActiveTank {
    """
    Specifies the tank an operator is currently using. Each plant usually has a dual tank system
    for coagulants and a separate tank for chlorine.
    """
    TANK_A
    TANK_B
}

type Plant @model(subscriptions: null) {
    """
    Represents a water treatment plant.

    Fields:
    id: Autogenerated unique identifier for the plant.
    name: Name of the plant.
    operators: List of operators working at the Plant.
    ____Entries: List of ___Entries associated with Plant, sorted by createdAt attribute.

    Relationships:
    Has many Operator entries.
    Has many entries of various data types for graphical visualization over varying time.
    """
    id: ID!
    name: String!
    # Field "id" refers to Plant.id, whose value aligns with Operator.plantID
    operators: [Operator] @hasMany(indexName: "OperatorByPlant", fields: ["id"])

    # Relationships: between Plant and Entry variants
    inflowEntries: [InflowEntry] @hasMany(indexName: "InflowByPlant", fields: ["id"])
    rawEntries: [RawEntry] @hasMany(indexName: "RawByPlant", fields: ["id"])
    clarifiedEntries: [ClarifiedEntry] @hasMany(indexName: "ClarifiedByPlant", fields: ["id"])
    filteredEntries: [FilteredEntry] @hasMany(indexName: "FilteredByPlant", fields: ["id"])
    calibrationEntries: [CalibrationEntry] @hasMany(indexName: "CalibrationByPlant", fields: ["id"])
    doseEntries: [DoseEntry] @hasMany(indexName: "DoseByPlant", fields: ["id"])
    feedbackEntries: [FeedbackEntry] @hasMany(indexName: "FeedbackByPlant", fields: ["id"])
}

type Operator @model(subscriptions: null) {
    """
    Represents an operator working at a plant.

    Fields:
    id: Autogenerated unique identifier for the operator.
    name: Name of the operator.
    plantID: Identifier of the plant the operator is associated with.
    ____Entries: List of ___Entries associated with Plant, sorted by createdAt attribute.

    Relationships:
    Belongs to a Plant.
    Has many entries variants for tracking operator submission history.
    """
    id: ID!
    name: String!
    # Creates an index whose primaryKey is made of partitionKey "plantID" and sortKey "Operator.id"
    plantID: ID! @index(name: "OperatorByPlant", sortKeyFields: ["id"])

    # Relationships: between Operator and Entry variants for operators' entry retrieval
    inflowEntries: [InflowEntry] @hasMany(indexName: "InflowByOperator", fields: ["id"])
    rawEntries: [RawEntry] @hasMany(indexName: "RawByOperator", fields: ["id"])
    clarifiedEntries: [ClarifiedEntry] @hasMany(indexName: "ClarifiedByOperator", fields: ["id"])
    filteredEntries: [FilteredEntry] @hasMany(indexName: "FilteredByOperator", fields: ["id"])
    calibrationEntries: [CalibrationEntry] @hasMany(indexName: "CalibrationByOperator", fields: ["id"])
    doseEntries: [DoseEntry] @hasMany(indexName: "DoseByOperator", fields: ["id"])
    feedbackEntries: [FeedbackEntry] @hasMany(indexName: "FeedbackByOperator", fields: ["id"])

    # Inverse relationship where each Operator belongs to a Plant
    plant: Plant @belongsTo(fields: ["plantID"])
}

type InflowEntry @model {
    """
    Represents an entry to capture the influent (incoming) water flow data.

    Fields:
    id (ID!): Autogenerated unique identifier for the inflow entry.
    createdAt (AWSDateTime!): Autogenerated timestamp of entry creation.
    plantID (ID!): Identifier of the plant.
    operatorID (ID!): Identifier of the operator who submitted the entry.
    inflowRate (Float!): Measured influent flow rate.
    notes (String): Additional notes or comments.

    Relationships:
    Belongs to a Plant.
    Belongs to an Operator.
    """
    id: ID!
    createdAt: AWSDateTime!
    plantID: ID! @index(name: "InflowByPlant", sortKeyFields: ["createdAt"])
    operatorID: ID! @index(name: "InflowByOperator", sortKeyFields: ["createdAt"])
    inflowRate: Float!
    notes: String

    # Inverse relationship between InflowEntry to their Plant or Operator
    plant: Plant @belongsTo(fields: ["plantID"])
    operator: Operator @belongsTo(fields: ["operatorID"])
}

type RawEntry @model {
    """
    Represents an entry to capture the raw water turbidity data.

    Relationships:
    Belongs to a Plant.
    Belongs to an Operator.
    """
    id: ID!
    createdAt: AWSDateTime!
    plantID: ID! @index(name: "RawByPlant", sortKeyFields: ["createdAt"])
    operatorID: ID! @index(name: "RawByOperator", sortKeyFields: ["createdAt"])
    turbidity: Float!
    notes: String
    plant: Plant @belongsTo(fields: ["plantID"])
    operator: Operator @belongsTo(fields: ["operatorID"])
}

type ClarifiedEntry @model {
    """
    Represents an entry to capture clarification turbidity data.

    Relationships (including Inverse):
    Belongs to a Plant.
    Belongs to an Operator.
    """
    id: ID!
    createdAt: AWSDateTime!
    plantID: ID! @index(name: "ClarifiedByPlant", sortKeyFields: ["createdAt"])
    operatorID: ID! @index(name: "ClarifiedByOperator", sortKeyFields: ["createdAt"])
    turbidity: Float!
    notes: String
    plant: Plant @belongsTo(fields: ["plantID"])
    operator: Operator @belongsTo(fields: ["operatorID"])
}

type FilteredEntry @model {
    """
    Represents an entry to capture each filter's turbidity data during filtration.

    Fields:
    turbidities: List of turbidities where List length (capped at six) corresponds to number of
    filters.

    Relationships:
    Belongs to a Plant.
    Belongs to an Operator.
    """
    id: ID!
    createdAt: AWSDateTime!
    plantID: ID! @index(name: "FilteredByPlant", sortKeyFields: ["createdAt"])
    operatorID: ID! @index(name: "FilteredByOperator", sortKeyFields: ["createdAt"])
    turbidities: [Float]!
    notes: String
    plant: Plant @belongsTo(fields: ["plantID"])
    operator: Operator @belongsTo(fields: ["operatorID"])
}

type CalibrationEntry @model {
    """
    Represents an entry to capture calibrating dosing equipment data. The entry data are
    partitioned into two sections - a required calibration, and an optional tank.

    Fields:
    inflowRate: Rate of water flow during calibration, which is different from InflowEntry.inflowRate.

    Relationships:
    Belongs to a Plant.
    Belongs to an Operator.
    Has a DoseEntry if available.
    """
    id: ID!
    createdAt: AWSDateTime!
    plantID: ID! @index(name: "CalibrationByPlant", sortKeyFields: ["createdAt"])
    operatorID: ID! @index(name: "CalibrationByOperator", sortKeyFields: ["createdAt"])
    chemicalType: ChemicalType!

    # Calibration data
    coagType: CoagType # Optional, only needed for COAGULANT
    sliderPosition: Float!
    inflowRate: Float!
    startVolume: Float!
    endVolume: Float!
    timeElapsed: Int!
    dose: Float!
    flowRate: Float!

    # Optional tank data
    activeTank: ActiveTank
    tankVolume: Float

    # One-to-one relationship with DoseEntry
    doseEntry: DoseEntry @hasOne

    # Inverse relationship with Plant and Operator
    plant: Plant @belongsTo(fields: ["plantID"])
    operator: Operator @belongsTo(fields: ["operatorID"])
}

type DoseEntry @model {
    """
    Represents an entry to capture the dosing adjustments data.

    Precondition
    Dosing is conducted post-calibration, thus requires a identifier to its corresponding CalibrationEntry.

    Fields:
    calibrationEntryID: Identifier of the associated calibration entry.
    calibrationEntry: The calibration entry a dose entry is based on.

    Relationships:
    Belongs to a Plant.
    Belongs to an Operator.
    Belongs to a CalibrationEntry.
    """
    id: ID!
    createdAt: AWSDateTime!
    plantID: ID! @index(name: "DoseByPlant", sortKeyFields: ["createdAt"])
    operatorID: ID! @index(name: "DoseByOperator", sortKeyFields: ["createdAt"])

    # Dosing data
    targetDose: Float!
    updatedSliderPosition: Float!
    updatedFlowRate: Float!

    # CalibrationEntry Inverse Relationships
    calibrationEntryID: ID! @index(name: "DoseByCalibration")
    calibrationEntry: CalibrationEntry @belongsTo(fields: ["calibrationEntryID"])

    # Plant and Operator Inverse Relationships
    plant: Plant @belongsTo(fields: ["plantID"])
    operator: Operator @belongsTo(fields: ["operatorID"])
}

type FeedbackEntry @model(subscriptions: null) {
    """
    Represents an entry to capture operator feedbacks.

    Relationships:
    Belongs to a Plant.
    Belongs to an Operator.
    """
    id: ID!
    createdAt: AWSDateTime!
    plantID: ID! @index(name: "FeedbackByPlant", sortKeyFields: ["createdAt"])
    operatorID: ID! @index(name: "FeedbackByOperator", sortKeyFields: ["createdAt"])
    feedback: String!
    plant: Plant @belongsTo(fields: ["plantID"])
    operator: Operator @belongsTo(fields: ["operatorID"])
}